-- Enhanced anti-burnout tracking schema
-- Add response time tracking to reviews table
alter table public.reviews add column if not exists response_time_ms integer;
alter table public.reviews add column if not exists hesitation_time_ms integer;
alter table public.reviews add column if not exists card_difficulty integer default 0;

-- Add burnout tracking table
create table if not exists public.burnout_tracking (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  assessment_date timestamptz default now(),
  risk_level text not null check (risk_level in ('low', 'medium', 'high')),
  risk_score integer not null check (risk_score between 0 and 100),
  indicators jsonb not null default '{}',
  recommendations text[] not null default '{}',
  created_at timestamptz default now()
);

alter table public.burnout_tracking enable row level security;

create policy "burnout_tracking_owner_access" on public.burnout_tracking
  for all using (user_id = auth.uid());

create index if not exists idx_burnout_tracking_user_date 
  on public.burnout_tracking (user_id, assessment_date desc);

-- Add workload tracking table
create table if not exists public.daily_workload (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  date date not null,
  cards_studied integer not null default 0,
  study_time_seconds integer not null default 0,
  session_count integer not null default 0,
  avg_fatigue_score decimal(5,2),
  overload_warning boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  unique(user_id, date)
);

alter table public.daily_workload enable row level security;

create policy "daily_workload_owner_access" on public.daily_workload
  for all using (user_id = auth.uid());

create index if not exists idx_daily_workload_user_date 
  on public.daily_workload (user_id, date desc);

-- Add session break tracking
create table if not exists public.study_breaks (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  session_id text, -- can link to study_logs if needed
  break_trigger text not null check (break_trigger in (
    'fatigue_detected', 'time_threshold', 'performance_drop', 'manual', 'smart_suggestion'
  )),
  break_taken boolean not null default false,
  break_duration_minutes integer,
  pre_break_fatigue_score integer,
  post_break_fatigue_score integer,
  effectiveness_score integer check (effectiveness_score between 0 and 100),
  break_started_at timestamptz not null,
  break_ended_at timestamptz,
  created_at timestamptz default now()
);

alter table public.study_breaks enable row level security;

create policy "study_breaks_owner_access" on public.study_breaks
  for all using (user_id = auth.uid());

create index if not exists idx_study_breaks_user_date 
  on public.study_breaks (user_id, break_started_at desc);

-- Update study_logs to include anti-burnout metrics
alter table public.study_logs add column if not exists fatigue_score integer;
alter table public.study_logs add column if not exists break_suggestions_triggered integer default 0;
alter table public.study_logs add column if not exists breaks_taken integer default 0;
alter table public.study_logs add column if not exists avg_response_time_ms integer;
alter table public.study_logs add column if not exists performance_trend text 
  check (performance_trend in ('improving', 'stable', 'declining'));

-- Function to update daily workload automatically
create or replace function update_daily_workload()
returns trigger as $$
begin
  insert into public.daily_workload (
    user_id, 
    date, 
    cards_studied, 
    study_time_seconds, 
    session_count,
    avg_fatigue_score
  )
  values (
    new.user_id,
    new.session_date::date,
    new.cards_studied,
    new.time_spent_seconds,
    1,
    new.fatigue_score
  )
  on conflict (user_id, date) do update set
    cards_studied = daily_workload.cards_studied + new.cards_studied,
    study_time_seconds = daily_workload.study_time_seconds + new.time_spent_seconds,
    session_count = daily_workload.session_count + 1,
    avg_fatigue_score = case 
      when new.fatigue_score is not null then
        (coalesce(daily_workload.avg_fatigue_score, 0) * daily_workload.session_count + new.fatigue_score) / (daily_workload.session_count + 1)
      else daily_workload.avg_fatigue_score
    end,
    overload_warning = (daily_workload.cards_studied + new.cards_studied) > 200,
    updated_at = now();
  
  return new;
end;
$$ language plpgsql;

-- Create trigger to automatically update daily workload
drop trigger if exists tr_update_daily_workload on public.study_logs;
create trigger tr_update_daily_workload
  after insert on public.study_logs
  for each row execute function update_daily_workload();

-- Function to get due cards with burnout-aware scheduling
create or replace function get_due_cards_anti_burnout(
  p_deck uuid,
  p_limit integer default 30,
  p_user_fatigue_score integer default 0
)
returns table (
  id uuid,
  deck_id uuid,
  type text,
  front text,
  back text,
  tags text[],
  difficulty double precision,
  last_studied timestamptz,
  next_due timestamptz,
  interval integer,
  ease_factor double precision,
  review_count integer
) language plpgsql as $$
begin
  -- Adjust difficulty threshold based on fatigue
  -- Higher fatigue = show easier cards first
  return query
  select 
    c.id,
    c.deck_id,
    c.type,
    c.front,
    c.back,
    c.tags,
    c.difficulty,
    c.last_studied,
    c.next_due,
    c.interval,
    c.ease_factor,
    c.review_count
  from public.cards c
  where c.deck_id = p_deck
    and c.next_due <= now()
    and exists (
      select 1 from public.decks d 
      where d.id = c.deck_id and d.owner_id = auth.uid()
    )
  order by 
    -- Prioritize easier cards when fatigued
    case when p_user_fatigue_score > 70 then c.difficulty else -c.difficulty end,
    c.next_due asc
  limit p_limit;
end;
$$;

-- Create indexes for performance
create index if not exists idx_reviews_response_time 
  on public.reviews (user_id, reviewed_at) where response_time_ms is not null;

create index if not exists idx_cards_difficulty_due 
  on public.cards (deck_id, difficulty, next_due) where next_due <= now();

-- Grant necessary permissions
grant usage on schema public to authenticated;
grant all on all tables in schema public to authenticated;
grant all on all sequences in schema public to authenticated;